<?xml version="1.0"?>
<doc>
    <assembly>
        "ClientAPI"
    </assembly>
    <members>
        <member name="M:ClientAPI.CRiskDataStore.FindItem(System.Int32,ClientAPI.CRiskItem*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Internal find function, to get an item only if it exists, by AccountID, 
or create if requested. Return true if the item had to be created. </summary>
        </member>
        <member name="M:ClientAPI.CRiskDataStore.FindOrCreateItem(System.Int32)">
            <summary>Finds or creates an item based on the supplied AccountID</summary>
            <param name="nAccountID">The AccountID for this CRiskItem</param>
            <returns>Should always return a valid CRiskItem object, empty if it has just created it</returns>
            <remarks>Use of this function to pre-create objects will result in never receiving an event with a exec type New(0)
as this is only ever set when creating the object</remarks>
        </member>
        <member name="M:ClientAPI.CRiskDataStore.FindItem(System.Int32)">
            <summary>Find an item based on an AccountID, returns nullptr if not present in the collection</summary>
        </member>
        <member name="T:EConnectionLostReason">
            <summary>An enumeration of disconnection reasons that can be supplied to the client when they receive the
OnConnectionLost event</summary>
        </member>
        <member name="F:eAdminLogoff">
            <summary>The administrator has forced the disconnect of this client</summary>
        </member>
        <member name="F:eDisconnected">
            <summary>Standard error reason, we have simply lost the connection to the server unexpectedly</summary>
        </member>
        <member name="M:CWebSessionPersistence.DeleteMessage(CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Delete a record specified by the category and the client supplied unique key </summary>
        </member>
        <member name="M:CWebSessionPersistence.GetMessages(CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.list&lt;CMessageFields&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Get a list of records for this user for a given category </summary>
        </member>
        <member name="M:CWebSessionPersistence.CreateMessage(CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CMessageFields*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Create or replace an existing record for this user </summary>
        </member>
        <member name="M:CWebSessionPersistence.GetCategories(CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.map&lt;CEasyString,CEasyString&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Get the list of categories the user is authorised to use </summary>
            <param name="strWebUserName">The client user name for this web session</param>
            <param name="strWebPassword">The client password for this web session</param>
            <param name="lsCategories">The returned collection of category names and descriptions allowed for this user</param>
            <returns>A value from the EEasyError enum representing the error that occurred or ErrorSuccess if successful</returns>
        </member>
        <member name="T:CWebSessionPersistence">
            <summary>
This class allows native calls into the EasyScreen.SOA2.WS.Persistence web service.
</summary>
        </member>
        <member name="D:CMessageFieldList">
            <summary> A collection of messages </summary>
        </member>
        <member name="T:CMessageFields">
            <summary> A native structure listing all the fields requried for a persisted message data contract </summary>
        </member>
        <member name="D:CCategoriesCollection">
            <summary> A collection of categories keyed by name with a description value </summary>
        </member>
        <member name="F:CCommsLayerManagement.m_dwHeartbeatPeriod">
            <summary>The time period in millisecs after inactivity we send heartbeats to the server</summary>
        </member>
        <member name="M:CCommsLayerManagement.ConnectionStatusThread">
            <summary>Dedicated thread that will deal with the connection state of the sites</summary>
            <remarks>Added to prevent a backlog of data building up while attempting to connect to any failed connections.
This is because we may have multiple connections and so long as at least one remains valid we need
to ensure we do not delay the processing thread or we will start to back up</remarks>
        </member>
        <member name="M:CCommsLayerTask.GetDisconnectReason">
            <summary>Sets the reason for the disconnect (if known), or eDisconnected otherwise</summary>
        </member>
        <member name="M:CCommsLayerTask.GetState">
            <summary>This flag indicates the state of the acknowledgment, Ack = True, Nak = false</summary>
        </member>
        <member name="M:CCommsLayerTask.SetDisconnectReason(EConnectionLostReason)">
            <summary>Sets the reason for the disconnect (if known), or eDisconnected otherwise</summary>
        </member>
        <member name="M:CCommsLayerTask.SetState(System.Boolean)">
            <summary>This flag indicates the state of the acknowledgment, Ack = True, Nak = false</summary>
        </member>
        <member name="M:CCommsLayerConnectionSite.HeartbeatIdleConnections(System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>Called to send heartbeats on all connections for this site that have had no data activity
for the specified period of time</summary>
            <param name="dwIdleInterval">The time period in millisecs that will trigger a heartbeat if a connection has been
inactive</param>
        </member>
        <member name="M:CCommsLayerConnectionSite.Stop">
            <summary>Ensures all worker threads are stopped for the underlying connection object</summary>
        </member>
        <member name="M:CCommsLayerConnectionSite.IsPartiallyConnected">
            <summary>Checks the current connections listed in the site and will return true if any of these are connected</summary>
            <returns>Returns True if any connection has a valid connection</returns>
        </member>
        <member name="M:CCommsLayerDataChannel.HeartbeatIdleConnections(System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>Called to send heartbeats on all connections for this data channel that have had no data activity
for the specified period of time</summary>
            <param name="dwIdleInterval">The time period in millisecs that will trigger a heartbeat if a connection has been
inactive</param>
        </member>
        <member name="M:CCommsLayerDataChannel.Stop">
            <summary>Ensures all worker threads are stopped for the underlying connection object</summary>
        </member>
        <member name="M:CCommsLayerDataChannel.IsPartiallyConnected">
            <summary>Determines if we have any valid connection</summary>
            <returns>Return True if we have any valid connection for this data channel</returns>
        </member>
        <member name="M:CCommsLayerConnection.ResubmitImageRequests(System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>Function to resubmit image requests that have not had a response within the supplied interval</summary>
            <param name="dwStaleInterval">The number of millisecs from kaing a request we would expect to have received an image returned</param>
        </member>
        <member name="M:CCommsLayerConnection.SendHeartbeat">
            <summary>Sends a heartbeat to the server to ensure this conenction is still valid, if this fails the connection
needs to be marked as failed</summary>
            <returns>Returns True if the connection has managed to successfully send a heartbeat otherwise False</returns>
        </member>
        <member name="M:CCommsLayerConnection.GetTimeSinceLastActivity">
            <summary>Returns the number of millices since any activity has (send or receive) has occurred on this 
connection</summary>
        </member>
        <member name="M:CCommsLayerConnection.HasSubmittedInterests(System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>Checks whether the given requestors identifier has sent an interest request since connecting</summary>
        </member>
        <member name="M:CCommsLayerConnection.Stop">
            <summary>Ensures all worker threads are stopped for the underlying connection object</summary>
        </member>
        <member name="M:CBasicOverlappedClient.ProcessClientAck(System.Byte!System.Runtime.CompilerServices.IsConst*,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary> This function is called upon receipt of a client ack message so the details can be extracted and the client notified </summary>
            <param name="pMsg">The ack message details which should contain the sending username and the message token</param>
            <param name="dwLength">The length of message that has been received</param>
        </member>
        <member name="M:CBasicOverlappedClient.SendHeartbeat">
            <summary>Sends a heartbeat to the server to ensure the connection is still valid as there are circumstances that
mean the connection has gone away and we do not notice until we attempt to send a message</summary>
            <returns>The function returns True if the send was success, otherwise returns False</returns>
        </member>
        <member name="M:CBasicOverlappedClient.SendMessageAck(System.Boolean,System.Int64,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> This function is used to send back an acknowledgment to the sending user for a particular message token</summary>
            <param name="bSuccess">A flag to indicate if this message was successful or not by the processing client</param>
            <param name="n64MsgToken">The message token attached to the received message so the receiver of the ack message can identify the message</param>
            <param name="strUsername">The user name of the recipient this acknowledgement is beign sent to</param>
            <returns> Returns true if this ack message was sent successfully otherwise false </returns>
        </member>
        <member name="M:CBasicOverlappedClient.SendData(System.Void!System.Runtime.CompilerServices.IsConst*,System.UInt32!System.Runtime.CompilerServices.IsLong,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean,System.Int64)">
            <summary> This function sends a block of data on EMH either as a broadcast (no destination username) or to a specific user (as specified) on
the group name supplied. The message can be encrypted and flagged as an image if required</summary>
            <param name="pData">The block of data (binary or ASCII) to be sent</param>
            <param name="dwDataLen">The length of the data block supplied in <paramref name="pData" /></param>
            <param name="strDestUsername">The destination user for the message if being sent point to point, or empty string if being broadcast</param>
            <param name="strGroupName">The group name or channel name for the message to be sent on</param>
            <param name="bEncrypt">A flag to indicate if this message should be encrypted before sending</param>
            <param name="bIsImage">A flag to indicate if this message is an image message, which is needed for some users to be received before any updates will be sent</param>
            <param name="nMessageToken">A client supplied message token that will be attached to the messageto identify this in the system</param>
            <returns> This function returns the number of bytes sent, zero if the send failed</returns>
        </member>
        <member name="M:CBasicOverlappedClient.SendData(System.Void!System.Runtime.CompilerServices.IsConst*,System.UInt32!System.Runtime.CompilerServices.IsLong,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean,System.UInt32!System.Runtime.CompilerServices.IsLong*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> This function sends a block of data on EMH either as a broadcast (no destination username) or to a specific user (as specified) on
the group name supplied. The message can be encrypted and flagged as an image if required</summary>
            <param name="pData">The block of data (binary or ASCII) to be sent</param>
            <param name="dwDataLen">The length of the data block supplied in <paramref name="pData" /></param>
            <param name="strDestUsername">The destination user for the message if being sent point to point, or empty string if being broadcast</param>
            <param name="strGroupName">The group name or channel name for the message to be sent on</param>
            <param name="bEncrypt">A flag to indicate if this message should be encrypted before sending</param>
            <param name="bIsImage">A flag to indicate if this message is an image message, which is needed for some users to be received before any updates will be sent</param>
            <param name="dwActualBytesSent">Will be set to the actual number of bytes that have been sent, after compression and including the protocol overhead</param>
            <returns> This function returns the message token to identify this message on the system, will be guarenteed unique in the system for one hour. If this send fails it return zero</returns>
        </member>
        <member name="M:CBasicOverlappedClient.SendData(System.Void!System.Runtime.CompilerServices.IsConst*,System.UInt32!System.Runtime.CompilerServices.IsLong,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean)">
            <summary> This function sends a block of data on EMH either as a broadcast (no destination username) or to a specific user (as specified) on
the group name supplied. The message can be encrypted and flagged as an image if required</summary>
            <param name="pData">The block of data (binary or ASCII) to be sent</param>
            <param name="dwDataLen">The length of the data block supplied in <paramref name="pData" /></param>
            <param name="strDestUsername">The destination user for the message if being sent point to point, or empty string if being broadcast</param>
            <param name="strGroupName">The group name or channel name for the message to be sent on</param>
            <param name="bEncrypt">A flag to indicate if this message should be encrypted before sending</param>
            <param name="bIsImage">A flag to indicate if this message is an image message, which is needed for some users to be received before any updates will be sent</param>
            <returns> This function returns the message token to identify this message on the system, will be guarenteed unique in the system for one hour. If this send fails it return zero</returns>
        </member>
        <member name="M:CConnectionActivity.GetLastImageActivity">
            <summary>Gets the number of millisecs since the last recorded image activity</summary>
        </member>
        <member name="M:CConnectionActivity.GetLastActivity">
            <summary>Gets the number of millisecs since the last recorded activity</summary>
        </member>
        <member name="M:CConnectionActivity.SetActivity(System.Boolean)">
            <summary>Sets the last activity timestamp to now</summary>
            <param name="bIsImageReceipt">Flag to indicate if this was an image receipt or not</param>
        </member>
        <member name="T:CConnectionActivity">
            <summary>This object holds the timestamp of the last activity of a connection and can extract the number
of millisecs since there was any activity</summary>
        </member>
        <member name="M:CPendingStreamImages.getStaleList(System.UInt32!System.Runtime.CompilerServices.IsLong,std.set&lt;CEasyString&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Retrieves a list of group names that have a time value set that is older than the supplied time period
from now</summary>
            <param name="dwStaleInterval">The time interval since a group name was last added</param>
            <param name="results">The set of group names that exceed the time interval</param>
        </member>
        <member name="M:CPendingStreamImages.clear(EInterestClearReason)">
            <summary>This function clears the collection</summary>
            <param name="eReason">A value from the <seealso cref="T:EInterestClearReason" /> enumeration that describes the 
reason for the clearing of the values</param>
        </member>
        <member name="M:CPendingStreamImages.remove(CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>This function removes a group name from the collection</summary>
            <param name="strGroupName">The group name that needs to be removed</param>
        </member>
        <member name="M:CPendingStreamImages.add(System.UInt32!System.Runtime.CompilerServices.IsLong,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>This function adds an interest name to the collection, an records the requesing instance for tracking.
If the entry is already found then the count is decremented by one. The caller needs to remove the item
once the retries reach zero</summary>
            <param name="dwKey">The requesting used for tracking the request</param>
            <param name="strGroupName">The interest that is being added</param>
            <returns>The remaining count left for retries</returns>
        </member>
        <member name="M:CPendingStreamImages.setDisplayName(CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>The connection display name that this collection is being held for</summary>
            <param name="strDisplayName">The connection display name (usually in the format 'ipaddress:port')</param>
        </member>
        <member name="T:CPendingStreamImages">
            <summary>A thread safe wrapper for the <seealso cref="D:CPendingImagesMap" /> dictionary that also adds 
logging and tracking</summary>
        </member>
        <member name="D:CPendingImagesMap">
            <summary>Dictionary of interest name to <seealso cref="D:CPendingImagesTimeAndCount" /> values</summary>
        </member>
        <member name="D:CPendingImagesTimeAndCount">
            <summary>Pair value of millisecs since 1970 and a retry count value</summary>
        </member>
        <member name="D:CPendingImagesSet">
            <summary>Collection of interest names</summary>
        </member>
        <member name="M:CInterestSubmissions.hasSubmittedFlag(System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>This function performs a lookup of the supplied instance identifier int he collection and returns
if the value is found</summary>
            <param name="dwKey">The instance identifier to be looked up</param>
            <returns>Returns True if the instances was found, otherwise returns False</returns>
        </member>
        <member name="M:CInterestSubmissions.add(System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>This function adds an instance to the collection of instances that have set themselves interested in
this interest name. If the instance is already in the collection it is not added again</summary>
            <param name="dwKey">The instance identifier to be added</param>
        </member>
        <member name="M:CInterestSubmissions.clear(EInterestClearReason)">
            <summary>Clears the collection of all instances</summary>
            <param name="eReason">A value from the <seealso cref="T:EInterestClearReason" /> collection to describe the reason for this clear</param>
        </member>
        <member name="M:CInterestSubmissions.setDisplayName(CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Sets the display name of the interest, this is the channel name that is being subscribed to</summary>
            <param name="strDisplayName">The interest name for this interest</param>
        </member>
        <member name="T:CInterestSubmissions">
            <summary>Thread safe wrapper around the <seealso cref="D:CInterestSubmissionSet" /> collection that also
add logging to actions to enable debugging and tracking when Verbose logging is enabled</summary>
        </member>
        <member name="T:EInterestClearReason">
            <summary>Enumeration that describes the reason a collection is cleared down, used for logging purposes</summary>
        </member>
        <member name="F:eInterestLostConnection">
            <value>We have lost connection to the server</value>
        </member>
        <member name="F:eInterestClientDisconnect">
            <value>We are requesting a disconnection</value>
        </member>
        <member name="F:eInterestInit">
            <value>We are being initialised</value>
        </member>
        <member name="D:CInterestSubmissionSet">
            <summary>Collection of instances that have submitted an interest in a particular group</summary>
        </member>
        <member name="P:ClientAPI.CRiskItemSecurityPosition.Position">
            <summary>A collection of fields that represent the Position fields sent by risk which are fields that generally
represent quantity values</summary>
        </member>
        <member name="P:ClientAPI.CRiskItemSecurityPosition.PosAmt">
            <summary>A collection of fields that represent the Position Amount fields sent by risk which are fields that
generally contain monetary values</summary>
        </member>
        <member name="P:ClientAPI.CRiskItemSecurityPosition.MarginGroupOffset">
            <summary>This value is used in TIMS style imports to indicate a percentage that will be rebated to instruments
within the product group that form a spread leaving one or instruments giving a margin rebate.</summary>
            <remarks>For example an instrument that would result a 100 EUR rebate would only be given 20 EUR rebate
if this value contains 0.20 (20%)</remarks>
        </member>
        <member name="P:ClientAPI.CRiskItemSecurityPosition.UnitTickValue">
            <summary>The unit tick value assigned to the instrument in EasyRouter</summary>
        </member>
        <member name="P:ClientAPI.CRiskItemSecurityPosition.CombinedCommodityCode">
            <summary>The code assigned to this commodity by the clearing house</summary>
        </member>
        <member name="P:ClientAPI.CRiskItemSecurityPosition.ClearingHouse">
            <summary>The clearing house code assigned to this instrument by the margin import</summary>
        </member>
        <member name="P:ClientAPI.CRiskItemSecurityPosition.TickerMnemonic">
            <summary>The instrument this summary is for</summary>
        </member>
        <member name="P:ClientAPI.CRiskItemSecurityPosition.Owner">
            <summary>The parent object for this summary</summary>
        </member>
        <member name="T:ClientAPI.CRiskItemSecurityPosition">
            <summary>
An instance of one of these describes the summary of the risk for an account instrument position
</summary>
        </member>
        <member name="P:ClientAPI.CAccountItem.ExchOrderTicketDefaults">
            <summary> All order ticket defaults for all exchanges keyed by security exchange </summary>
            <returns> A copy of the internal dictionary if valid, an empty dictionary if not and null if it fails to get the lock </returns>
        </member>
        <member name="P:ClientAPI.CAccountItem.Group">
            <summary>The account group this account belongs to</summary>
        </member>
        <member name="P:ClientAPI.CAccountItem.Permissions">
            <summary>Permissions (view, trade, both or none) the trader has</summary>
        </member>
        <member name="P:ClientAPI.CAccountItem.Name">
            <summary>Account name</summary>
        </member>
        <member name="P:ClientAPI.CAccountItem.Code">
            <summary>Account code in the EasyRouter system (may or may not be same as name)</summary>
        </member>
        <member name="P:ClientAPI.CAccountItem.ID">
            <summary>Account identifier in the EasyRouter system</summary>
        </member>
        <member name="P:ClientAPI.COrderStateTree.OverallState">
            <summary>Read-only property to extract the current overall status</summary>
        </member>
        <member name="M:ClientAPI.COrderStateTree.SetOrderState(System.String,System.Int32,ClientAPI.EItemState)">
            <summary>Sets the state for order instance against an exchange and returns the overall status for orders</summary>
        </member>
        <member name="M:ClientAPI.COrderStateTree.AddOrderInstance(System.String,System.Int32)">
            <summary>Creates an empty entry for an order instance ready for the receipt of instance update</summary>
        </member>
        <member name="M:ClientAPI.COrderStateTree.AddExchange(System.String)">
            <summary>Create an exchange entry ready for receipt of an order instance status update</summary>
        </member>
        <member name="P:ClientAPI.COrderInstanceState.Status">
            <summary>Read-only property to get teh current overall status for all order instances</summary>
        </member>
        <member name="M:ClientAPI.COrderInstanceState.AddInstance(System.Int32)">
            <summary>Add a new instance if this is not already known</summary>
        </member>
        <member name="M:ClientAPI.COrderInstanceState.UpdateInstance(System.Int32,ClientAPI.EItemState)">
            <summary>Sets the status for an individual order instance, and returns the overall status</summary>
        </member>
        <member name="P:ClientAPI.COrderDataStore.AccountList(System.Int32)">
            <summary>This read-only property gets the <seealso cref="D:ClientAPI.COrderItemList" /> collection of order items for the supplied AccountID parameter,
if the supplied account id is not found then a null object is returned instead of an empty collection. If the account is found the
actual internal list object is returned not a copy</summary>
        </member>
        <member name="P:ClientAPI.COrderDataStore.Orders">
            <summary>This read-only property gets the internal order <seealso cref="D:ClientAPI.COrderCache">cache</seealso> object (not a copy) that holds all the order item objects</summary>
        </member>
        <member name="M:ClientAPI.COrderDataStore.UnregisterAccountInterest(System.Int32)">
            <summary>This function removes an interest in account order events for a known account identifier</summary>
            <param name="_accountID">The EasyRouter account identifier the client is requesting orders for</param>
            <remarks>No permission checks are done with this function as closing a channel that was not opened will have no effect 
and they were permissioned when attempting to open the channel</remarks>
        </member>
        <member name="M:ClientAPI.COrderDataStore.RegisterAccountInterest(System.Int32,ClientAPI.CUserInfo)">
            <summary>Registers this account data store to receive order events for a known account identifier</summary>
            <param name="_accountID">The EasyRouter account identifier the client is requesting orders for</param>
            <param name="_userInfo">The user information object that contains the user details that is making the request</param>
            <returns>This function returns True if the channel interest was opened, otherwise it returns False</returns>
            <remarks>To ensure clients are only requesting orders for accounts they have permissions on this function will check the account
identifier is already known to the account data store, any failure (such as passing an invalid user info object) to find the account 
identifier will result in no action in this function and result of false to be returned. Server side users may pass
a null _userInfo object into this parameter as they are authorised to request all accounts.</remarks>
        </member>
        <member name="M:ClientAPI.COrderDataStore.FindItem(System.String)">
            <summary>Get an item only if it exists, by internal unique ID</summary>
            <param name="strUniqueID">The EasyRouter generated unique order identifier that is set against a new order until a BOID as been assigned by the database</param>
            <returns>The <seealso cref="T:ClientAPI.COrderItem" /> instance that is found by the BOID, or Null if no item was found</returns>
        </member>
        <member name="M:ClientAPI.COrderDataStore.FindItem(System.UInt64)">
            <summary>Get an item only if it exists, by BOID</summary>
            <param name="nPrimaryBOID">The EasyRouter unique order identifier that identifies the order to be looked up</param>
            <returns>The <seealso cref="T:ClientAPI.COrderItem" /> instance that is found by the BOID, or Null if no item was found</returns>
        </member>
        <member name="M:ClientAPI.COrderDataStore.EnrichOrderItem(ClientAPI.COrderItem)">
            <summary>Takes a <seealso cref="T:ClientAPI.COrderItem" /> object, finds a structure item based on the Mnemonic property on the object, 
and adds the following fields if not already set on the COrderItem:<list type="bullet"><item>ESTickerSymbol</item><item>SecurityExchange</item><item>ESExchange</item><item>Symbol</item><item>SecurityType</item><item>CFICode</item><item>StrategyCode</item><item>ESDecimalPlaces</item></list>
Additionally, if the StrategyCode is not set, this is considered to be an outright, and the following will also be enhanced:<list type="bullet"><item>ESCombinedCommodityCode</item><item>ESClearingHouse</item><item>RiskArrays</item></list>
In addition, for clients that have a structure item or an account item cached, there are EnrichFromStructure|Account 
functions on the Place/Edit/Cancel wrappers (which are actually also called by the EnrichOrderItem internally).</summary>
            <returns>Returns true if the Mnemonic was found and enhancement attempted.</returns>
        </member>
        <member name="M:ClientAPI.COrderDataStore.PullOrder(System.UInt64,ClientAPI.CUserInfo)">
            <summary>This method takes the BOID value of the order that is being pulled and a <seealso cref="T:ClientAPI.CUserInfo" /> instance and will attempt to lookup the original 
order to build the pull request.</summary>
            <param name="nPrimaryBOID">The EasyRouter unique order identifier that identifies which order is to be pulled</param>
            <param name="pUserInfo">The <seealso cref="T:ClientAPI.CUserInfo" /> object that has the details of the user that is making the request</param>
            <returns>This function returns True if the pull request was sent successfully, otherwise it returns False</returns>
        </member>
        <member name="M:ClientAPI.COrderDataStore.PullOrder(ClientAPI.COrderPullItem,ClientAPI.CUserInfo)">
            <summary>This method takes takes a <seealso cref="T:ClientAPI.COrderPullItem" /> instance and a <seealso cref="T:ClientAPI.CUserInfo" /> instance to build the order pull request</summary>
            <param name="pPullOrder">The <seealso cref="T:ClientAPI.COrderPullItem" /> that contains order details that the pull request is for</param>
            <param name="pUserInfo">The <seealso cref="T:ClientAPI.CUserInfo" /> object that has the details of the user that is making the request</param>
            <returns>This function returns True if the pull request was sent successfully, otherwise it returns False</returns>
        </member>
        <member name="M:ClientAPI.COrderDataStore.EditOrder(System.UInt64,ClientAPI.CUserInfo,System.Int32,System.Double,System.Double)">
            <summary>This method takes the BOID value of the order that is being edited, a UserInfo instance, the volume delta and a new price and will attempt to 
lookup the original order and apply these new values to it. It does this by building a <seealso cref="T:ClientAPI.COrderEditItem" /> object from the supplied values</summary>
            <param name="nPrimaryBOID">The EasyRouter unique order identifier that identifies which order is to be edited</param>
            <param name="pUserInfo">The <seealso cref="T:ClientAPI.CUserInfo" /> details for the user that is making the request</param>
            <param name="nNewVolDelta">The delta for the order volume to be applied, supply 0 for no change</param>
            <param name="dNewPrice">The new price for the order. The price field is not validated and supplied to the edit request as supplied</param>
            <param name="dNewStopPx">The new stop price for the order. The stop price is not validated and supplied to the edit request as supplied</param>
            <returns>The function returns True if the edit request was successfully sent, otherwise returns False</returns>
        </member>
        <member name="M:ClientAPI.COrderDataStore.EditOrder(ClientAPI.COrderEditItem,ClientAPI.CUserInfo)">
            <summary>This method takes an OrderEditItem instance and a UserInfo instance to build the order edit request</summary>
            <param name="pEditOrder">The <seealso cref="T:ClientAPI.COrderEditItem" /> object that references the original order and the new values for the order</param>
            <param name="pUserInfo">The <seealso cref="T:ClientAPI.CUserInfo" /> details for the user that is making the request</param>
            <returns>The function returns True if the edit request was successfully sent, otherwise returns False</returns>
        </member>
        <member name="M:ClientAPI.COrderDataStore.PlaceComboOrder(ClientAPI.COrderEntryItem,ClientAPI.COrderEntryItem)">
            <summary>This method takes two OrderEntryItem objects, one for the buy side and one for the sell side of a ComboOrder which will hold all the 
fields needed to format and send a new combo order request.</summary>
            <param name="pBuyOrder">An instance of a <seealso cref="T:ClientAPI.COrderEntryItem" /> object that holds the buy side order fields</param>
            <param name="pSellOrder">An instance of a <seealso cref="T:ClientAPI.COrderEntryItem" /> object that holds the sell side order fields</param>
            <returns>The function returns True if the request was successfully sent, otherwise returns False</returns>
        </member>
        <member name="M:ClientAPI.COrderDataStore.PlaceOrder(ClientAPI.COrderEntryItem)">
            <summary>This method takes an instance of an OrderEntryItem object which will hold all the fields needed to format and send a new order request.</summary>
            <param name="pNewOrder">An instance of a <seealso cref="T:ClientAPI.COrderEntryItem" /> object that holds the new order fields</param>
            <returns>The function returns True if the new order request was successfully sent, otherwise returns False</returns>
        </member>
        <member name="T:ClientAPI.COrderDataStore">
            <summary>This data store is responsible for the submission of order requests and the processing of order updates
as they arrive. It deals with all orders for all accounts. Users are expected to register to receive order events 
via the account item event interface. This will register for the events on this data store but means the end user 
can receive the event notifications with the account item context instead of needing to do a separate lookup based
on the order item fields. This data store does expose an event interface in case the end user is not interested in 
the accounts details but needs to see all orders for this connection. Due to the capability to share accounts across 
users in EasyRouter accessing the order events via the account item events would mean the front end application 
receives the same order event for each account item instance that exists and will need to handle this design feature.
The order hierarchy is set such that the OrderItem that is returned is always the current overall state of any given 
order. The OrderItem contains a collection of OrderEventItems, one for every event that is received for the order over 
its lifetime. The OrderEventItem is built based on the contents of an update to the order and the OrderItem updates its 
order properties based on these changes. Therefore any implementation need only view the current order properties to see 
the current state of an order but can also query the OrderItem for the full list of events if these are needed.
Updates to the order item cannot occur while within the event handler for an order item therefore the order item given 
in the event can be deemed thread safe, although if the item were cached by a front end application these value might be 
changed without protection. Therefore it is recommended the event is processed and the item is not cached between events.</summary>
        </member>
        <member name="D:ClientAPI.CStatusPrecedence">
            <summary>A dictionary of execution types to the order precedence the status will be taken in when multiple execution states appear against an order</summary>
        </member>
        <member name="D:ClientAPI.CAccountOrderCache">
            <summary>A dictionary collection of order items keyed by the account id the order was placed against, the value is a list of order items</summary>
        </member>
        <member name="D:ClientAPI.COrderItemList">
            <summary>List collection of COrderItems</summary>
        </member>
        <member name="D:ClientAPI.COrderCacheByInternal">
            <summary>A dictionary of order items keted by the unique identifier for the order that assigned before a BOID is created, the value if the 
order item the unique identifier refers to</summary>
        </member>
        <member name="M:ClientAPI.COrderItem.FindEventItem(System.UInt64)">
            <summary> Looks up and extracts an event record based on the order event id supplied </summary>
            <param name="nSecondaryOrderID"> The secondary order id to be found (event id) </param>
            <returns> The OrderEventItem record of the supplied id if found, otherwise null </returns>
        </member>
        <member name="P:ClientAPI.COrderItem.MinOrderQty">
            <summary> The minimum fill quantity, set to any negative number to prevent this field from being sent </summary>
        </member>
        <member name="P:ClientAPI.COrderItem.OrderQty">
            <summary> The order quantity, will always be sent </summary>
        </member>
        <member name="P:ClientAPI.COrderItem.ESPriceFormatCode">
            <summary> The price format code value, set to any negative number to prevent this field from being sent </summary>
        </member>
        <member name="P:ClientAPI.COrderItem.ESDecimalPlaces">
            <summary> The number of decimal places, set to any negative number to prevent this field from being sent </summary>
        </member>
        <member name="P:ClientAPI.COrderItem.PutOrCall">
            <summary> The Put(0) or Call(1) flag for an option, any other value should prevent field from being set in sent messages </summary>
        </member>
        <member name="P:ClientAPI.COrderItem.ESCustomerData">
            <summary> 
This field is used to hold any customer data value the application wishes. The value will be persisted
by the system and returned on order events.
</summary>
        </member>
        <member name="P:ClientAPI.COrderItem.EventESCustomerData">
            <summary> 
This property exposes the ESCustomerData field value for the event that has been received. This is exposed
as a seperate field from the ESCustomerData field of the order item to allow for external order modification
that would result in an order event being triggered without this value being set, or being set with the external
applications own reference in here. In which case the client can still access the value set in the ESCustomerData
field. If the event requires the ESCustomerData field to be updated to a new value the application must be this.
</summary>
        </member>
        <member name="P:ClientAPI.COrderItem.AvgPx">
            <summary>Read only property that will be the calculated average trade price for this order based on all
fills that have occurred. If there have been no fills then this will 0.0</summary>
            <value>This property is a value type of Double</value>
        </member>
        <member name="P:ClientAPI.COrderFieldsIntAttribute.MaxValue">
            <summary> The maximum value the property is allow to have and still be valid </summary>
        </member>
        <member name="P:ClientAPI.COrderFieldsIntAttribute.MinValue">
            <summary> The minimum value the property is allow to have and still be valid </summary>
        </member>
        <member name="T:ClientAPI.COrderFieldsIntAttribute">
            <summary> This class set the attributes for signed int 32 properties so they can have a validity range
if the property value is outside this range when building the message the property is not added to the message </summary>
        </member>
        <member name="P:ClientAPI.COrderFieldsAttribute.FIXField">
            <summary> This property will contain the FIX tag that will be set in the message containing the property value </summary>
        </member>
        <member name="T:ClientAPI.COrderFieldsAttribute">
            <summary> This class sets attributes against properties that can be queried for to determine 
the property state, such as validity </summary>
        </member>
        <member name="P:ClientAPI.COrderEventItem.EventOrderType">
            <summary>Stop orders can alter the order type from the original, this is the fix ordtype(40) found on the exec report</summary>
        </member>
        <member name="P:ClientAPI.COrderEventLegFill.Mnemonic">
            <summary> The leg instrument identifier which can be used to check the leg ordering </summary>
        </member>
        <member name="P:ClientAPI.COrderEventLegFill.ExecID">
            <summary> The execution identifier for this leg fill </summary>
        </member>
        <member name="P:ClientAPI.COrderEventLegFill.Volume">
            <summary> The fill volume for this leg </summary>
        </member>
        <member name="P:ClientAPI.COrderEventLegFill.Price">
            <summary> The fill price for this leg </summary>
        </member>
        <member name="P:ClientAPI.COrderEventLegFill.LegNo">
            <summary> The leg number of the fill, note this may not be the order as the structure definition. Leg numbers are 1 based. </summary>
        </member>
        <member name="T:ClientAPI.COrderEventLegFill">
            <summary> List object will hold details about the legs for fill events, the order
event will hold a collection of these (one for each leg). </summary>
        </member>
        <member name="F:ClientAPI.CAccountDataStore.m_hCompletionEvent">
            <value> The member variable that holds the event handle that will be trigger when this object sets it state to completed </value>
        </member>
        <member name="F:ClientAPI.CAccountDataStore.m_eOverallState">
            <summary>Variable to hold the combined state of the account list and the order batching</summary>
        </member>
        <member name="F:ClientAPI.CAccountDataStore.m_eState">
            <summary>Variable to hold the account list state</summary>
        </member>
        <member name="P:ClientAPI.CAccountDataStore.CompletionEvent">
            <summary> An event handle that users can wait on for a completion notification </summary>
        </member>
        <member name="P:ClientAPI.CAccountDataStore.OverallState">
            <summary>Overall state of account list and orders</summary>
        </member>
        <member name="F:ClientAPI.CStatusDataStore.m_bDisconnectRequested">
            <summary>Flag variable to indicate when we are unexpectedly disconnected from the server to enable
sending of user status updates</summary>
        </member>
        <member name="M:ClientAPI.CStatusDataStore.ProcessLogoffForAllUsers">
            <summary>This function will iterate over all users currently logged on and set them to logged off</summary>
        </member>
        <member name="M:ClientAPI.CStatusDataStore.ProcessLogoffUser(ClientAPI.CUserInfo)">
            <summary>Common function called during the normal logoff response processing and also from an unexpected
disconnect event</summary>
            <param name="pUserInfo">The <seealso cref="T:ClientAPI.CUserInfo" /> object that holds the current user information</param>
        </member>
        <member name="E:ClientAPI.CStatusDataStore.OnExchangeStatusChange">
            <summary>Fired on a change to an exchange status change</summary>
        </member>
        <member name="E:ClientAPI.CStatusDataStore.OnComponentStatusChange">
            <summary>Fired on a change to an easyrouter component status change</summary>
        </member>
        <member name="E:ClientAPI.CStatusDataStore.OnConnectionStatusChange">
            <summary>Fired on a change to the connection status</summary>
        </member>
        <member name="E:ClientAPI.CStatusDataStore.OnUserStatusChange">
            <summary>Fired on a change in user status (logged on/logged off)</summary>
        </member>
        <member name="E:ClientAPI.CStatusDataStore.OnPreConnectAuth">
            <summary>Fired on response from a preconnect request</summary>
        </member>
        <member name="M:ClientAPI.CStatusDataStore.SetStaticConfiguration(System.String)">
            <summary>Sets the configuration string that will be used to configure the clientapi, which will be taken as static and not
replaced by any users permissions</summary>
            <param name="strConfig">The XML formatted configuration string to be used for connection details and permissions</param>
        </member>
        <member name="M:ClientAPI.CStatusDataStore.RemoveUserInfo(ClientAPI.CUserInfo)">
            <summary>Takes a <seealso cref="T:ClientAPI.CUserInfo" /> parameter, and if found in the internal Username dictionary the entry will 
be removed.  This must be called by clients which are managing their own CUserInfo logon if they are going to attempt 
to create a new object per logon, as the existing object will be tied to the Username and so any new object with the same 
name will be rejected. It is perfectly valid to keep the object and simply reuse it if the existing committed name is 
acceptable, although this pattern is not anticipated to be used much – the anticipated pattern is instantiation of a new 
CUserInfo object per logon attempt, using it as the backing data store for a bound form.</summary>
            <param name="pUserInfo">The user information object to be removed if found</param>
            <returns>Returns True if the details were found and removed from the collection</returns>
        </member>
        <member name="M:ClientAPI.CStatusDataStore.GetUserInfo(System.String)">
            <summary>Gets the user's information from the underlying store, located by the supplied user name</summary>
            <param name="strUsername">The username to get the information for</param>
            <returns>The <seealso cref="T:ClientAPI.CUserInfo" /> object with the first users information or null if no details exist</returns>
        </member>
        <member name="M:ClientAPI.CStatusDataStore.GetUserInfo">
            <summary>Gets the first user's information from the underlying store, if any exist</summary>
            <returns>The <seealso cref="T:ClientAPI.CUserInfo" /> object with the first users information or null if no details exist</returns>
        </member>
        <member name="M:ClientAPI.CStatusDataStore.GetActiveSessionsCount">
            <summary> Get the number of active user sessions remaining via this instance</summary>
            <returns>The number of active sessions remaining</returns>
        </member>
        <member name="M:ClientAPI.CStatusDataStore.GetCommunicationsStateObj">
            <summary>Gets the state holding object that holds the state information for the communication layer</summary>
            <returns>This method returns the object that holds the state information for the communications layer.</returns>
        </member>
        <member name="M:ClientAPI.CStatusDataStore.GetCommunicationsState">
            <summary>Gets the current communication state value</summary>
            <returns>Returns the current communications state expressed as a value from the <seealso cref="T:ClientAPI.EComponentStatusValues" /> enumeration</returns>
        </member>
        <member name="M:ClientAPI.CStatusDataStore.SendClientHeartBeat(ClientAPI.CUserInfo)">
            <summary>This method takes a <seealso cref="T:ClientAPI.CUserInfo" /> as a parameter which contains the user information
and formats a heartbeat protocol message of that user and sends this. Calling this method frequently (approx every 30 seconds)
should avoid the users session being marked as stale within EasyRouter.</summary>
            <param name="pUserInfo">The <seealso cref="T:ClientAPI.CUserInfo" /> details that is having a heartbeat sent for it</param>
        </member>
        <member name="M:ClientAPI.CStatusDataStore.SendClientHeartBeat(System.String)">
            <summary>This method takes the EasyRouter username as a parameter and formats a heartbeat protocol message of 
that user and sends this. Calling this method frequently (approx every 30 seconds) should avoid the users session 
being marked as stale within EasyRouter.</summary>
            <param name="strUsername">The username that is having a heartbeat sent for it</param>
        </member>
        <member name="M:ClientAPI.CStatusDataStore.RequestDisconnect">
            <summary>This method will send a Disconnect message object into the routing layer. This method is asynchronous
and completion will be notified by the <seealso cref="E:ClientAPI.CStatusDataStore.OnConnectionStatusChange" /> event signalling the connection state as false.</summary>
        </member>
        <member name="M:ClientAPI.CStatusDataStore.RequestConnect">
            <summary>This method will create and send a Connect message object to the routing layer, 
if the configuration settings have changed since the last call to Connect these will be sent
with the message as well. This method is asynchronous and completion will be signalled by the 
business object by invoking the <seealso cref="E:ClientAPI.CStatusDataStore.OnConnectionStatusChange" /> if/when the connection state is changed.</summary>
        </member>
        <member name="M:ClientAPI.CStatusDataStore.RequestLogoff(ClientAPI.CUserInfo)">
            <summary>This method will format and send a logoff request to the routing layer for a given user. This method is 
asynchronous and completion will be done by firing the <seealso cref="E:ClientAPI.CStatusDataStore.OnUserStatusChange" /> event. The current session information
will also be reset for the username in question.</summary>
            <param name="pUserInfo">A <seealso cref="T:ClientAPI.CUserInfo" /> object contain the user details for the logoff request</param>
            <returns>This function returns True if the request was formatted and sent successfully to the routing layer</returns>
        </member>
        <member name="M:ClientAPI.CStatusDataStore.RequestLogoff(System.String)">
            <summary>This method will format and send a logoff request to the routing layer for a given user. This method is 
asynchronous and completion will be done by firing the <seealso cref="E:ClientAPI.CStatusDataStore.OnUserStatusChange" /> event. The current session information
will also be reset for the username in question.</summary>
            <param name="strUsername">The username to be logged off</param>
            <returns>This function returns True if the request was formatted and sent successfully to the routing layer</returns>
        </member>
        <member name="M:ClientAPI.CStatusDataStore.RequestLogon(ClientAPI.CUserInfo)">
            <summary>This method will format a logon request for a given user and then send this on to the Routing Layer. The
method is asynchronous and completion will be signalled by firing the <seealso cref="E:ClientAPI.CStatusDataStore.OnUserStatusChange" />
event indicating the success or failure of the request.</summary>
            <param name="pUserInfo">A <seealso cref="T:ClientAPI.CUserInfo" /> object contain the user details for the logon request</param>
            <returns>This function returns True if the request was formatted and sent successfully to the routing layer</returns>
        </member>
        <member name="M:ClientAPI.CStatusDataStore.RequestLogon(System.String)">
            <summary>This method will format a logon request for a given user and then send this on to the Routing Layer. The
method is asynchronous and completion will be signalled by firing the <seealso cref="E:ClientAPI.CStatusDataStore.OnUserStatusChange" />
event indicating the success or failure of the request.</summary>
            <param name="strUsername">The username to be requested</param>
            <returns>This function returns True if the request was formatted and sent successfully to the routing layer</returns>
        </member>
        <member name="M:ClientAPI.CStatusDataStore.RequestPreConnectAuth(ClientAPI.CUserInfo)">
            <summary>This method will attempt to authenticate the user’s details with the web server
and if successful will receive the set of connection details and other configuration values for this user. 
The function is asynchronous and returns true or false to indicate the ability to pass the request on to the
routing layer. When this request completes the business object fires the <seealso cref="E:ClientAPI.CStatusDataStore.OnPreConnectAuth" /> event when complete
to indicate success or failure of the request.</summary>
            <param name="pUserInfo">The <seealso cref="T:ClientAPI.CUserInfo" /> object containing all the user details required for a logon attempt</param>
            <returns>Returns True if the request was passed on to the routing layer successfully</returns>
        </member>
        <member name="M:ClientAPI.CStatusDataStore.RequestPreConnectAuth(System.String,System.String,System.String,System.String,System.String,System.Boolean)">
            <summary>This method will attempt to authenticate the user’s details with the web server
and if successful will receive the set of connection details and other configuration values for this user. 
The function is asynchronous and returns true or false to indicate the ability to pass the request on to the
routing layer. When this request completes the business object fires the <seealso cref="E:ClientAPI.CStatusDataStore.OnPreConnectAuth" /> event when complete
to indicate success or failure of the request.</summary>
            <param name="strUsername">The EasyRouter username used for authentication</param>
            <param name="strPassword">The logon password</param>
            <param name="strLocation">The web server URL to used to authenticate the user credentials</param>
            <param name="strClientType">TBD</param>
            <param name="strBrandIdentifier">TBD</param>
            <param name="bDeferToExistingSession">Flag to indicate if the logon should override any existing active session found for the given user</param>
            <returns>Returns True if the request was passed on to the routing layer successfully</returns>
        </member>
        <member name="M:ClientAPI.CStatusDataStore.Uninitialise">
            <inheritdoc />
        </member>
        <member name="M:ClientAPI.CStatusDataStore.Initialise(ClientAPI.CManagement)">
            <inheritdoc />
        </member>
        <member name="M:ClientAPI.CStatusDataStore.OnStatusData(CMessageObject*)">
            <summary>Event handler for the receipt of status update data</summary>
        </member>
        <member name="M:ClientAPI.CStatusDataStore.GetUserInfoBySession(System.String)">
            <summary>Lookup user info by name or session id, these need to be made public internally
to allow use by other business objects but are not exposed outside the ClientAPI</summary>
            <param name="strSessionID">The users session identifier that is used to lookup the user information</param>
            <returns>A <seealso cref="T:ClientAPI.CUserInfo" /> object containing the user information for the given session, or null if not found</returns>
        </member>
        <member name="T:ClientAPI.CStatusDataStore">
            <summary>This data store business object will contain all current logon session information, such as Session ID 
for each user that is currently logged in. It will also hold all status information such as connection, component and exchange status.</summary>
        </member>
        <member name="P:ClientAPI.CUserInfo.PersistenceImpl">
            <summary> Internal property for extracting the underlying persistence implemetation in order to pass on responses back from the web service </summary>
        </member>
        <member name="M:ClientAPI.CUserInfo.VersionRequest(System.Xml.XmlDocument)">
            <summary>This funtion currently has no implmentation and is here for future use</summary>
            <remarks>Do not use until this has been implemented</remarks>
        </member>
        <member name="M:ClientAPI.CUserInfo.ProfileRequest(System.Xml.XmlDocument)">
            <summary>This function has been deprecated, see the <seealso cref="P:ClientAPI.CUserInfo.Persistence" /> property instead which performs data storage and
retrieval generically and should be used for profile</summary>
        </member>
        <member name="M:ClientAPI.CUserInfo.RemoveUserFromDataStore">
            <summary>Removes the <seealso cref="T:ClientAPI.CUserInfo" /> object from the general CStatusDataStore collections. To be invoked by clients that
create and manage their own CUserInfo instances when they are to be destroyed, so that they are correctly released.</summary>
            <returns>Function returns True if the user details were removed successfully</returns>
        </member>
        <member name="P:ClientAPI.CUserInfo.Persistence">
            <summary>This property exposes the persistence interface this object can use to store data generically. See <seealso cref="T:ClientAPI.IPersistence" /> for storage methods</summary>
            <remarks>This property is read-only</remarks>
        </member>
        <member name="P:ClientAPI.CUserInfo.LogonRequestTime">
            <summary>This property can be used to hold the time stamp of the last logon request time, so we
are able to time out a failed logon request when we fail to receive a logon response</summary>
            <remarks>This property is read-only outside of the library</remarks>
        </member>
        <member name="P:ClientAPI.CUserInfo.Committed">
            <summary>Indicate whether the Username can still be validly modified. This is set to true once a logon has been requested.</summary>
            <remarks>This property is read-only outside of the library</remarks>
        </member>
        <member name="P:ClientAPI.CUserInfo.Accounts">
            <summary>Access to the <seealso cref="T:ClientAPI.CAccountDataStore">account data store</seealso> for this user</summary>
            <remarks>This property is read-only outside of the library</remarks>
        </member>
        <member name="P:ClientAPI.CUserInfo.LastErrorText">
            <summary>Error text of the last error that occurred</summary>
            <remarks>This property is read-only outside of the library</remarks>
        </member>
        <member name="P:ClientAPI.CUserInfo.UserCurrentState">
            <summary>Current status of this user, value will be one of the enumerated values from EUserStatusValues.</summary>
            <remarks>This property is read-only outside of the library</remarks>
        </member>
        <member name="P:ClientAPI.CUserInfo.PrimaryBOID">
            <summary>Primary BOID value, unused except for formatted internal protocol messages</summary>
            <remarks>This property is read-only outside of the library</remarks>
        </member>
        <member name="P:ClientAPI.CUserInfo.SequenceNumber">
            <summary>The current sequence number</summary>
            <remarks>This property is read-only outside of the library</remarks>
        </member>
        <member name="P:ClientAPI.CUserInfo.EnvironmentType">
            <summary>The type of EasyRouter that responded to the logon (unknown/dummy/trainer/live)</summary>
            <remarks>This property is read-only outside of the library</remarks>
        </member>
        <member name="P:ClientAPI.CUserInfo.EnvironmentName">
            <summary>The name of the EasyRouter which resonded to the logon</summary>
            <remarks>This property is read-only outside of the library</remarks>
        </member>
        <member name="P:ClientAPI.CUserInfo.FrontEndVersion">
            <summary>The current version of the front end binary</summary>
            <remarks>This property is read-only outside of the library</remarks>
        </member>
        <member name="P:ClientAPI.CUserInfo.FrontEndBinaryName">
            <summary>The front end binary name</summary>
            <remarks>This property is read-only outside of the library</remarks>
        </member>
        <member name="P:ClientAPI.CUserInfo.CurrentSessionID">
            <summary>The current session identifier for the user. Only valid once a logon has completed successfully</summary>
            <remarks>This property is read-only outside of the library</remarks>
        </member>
        <member name="P:ClientAPI.CUserInfo.RoleID">
            <summary>The EasyRouter Role assigned to this username that is used to check they are permitted to perform any requested action</summary>
            <remarks>This property is read-only outside of the library</remarks>
        </member>
        <member name="P:ClientAPI.CUserInfo.DeferToExistingSessions">
            <summary>A flag to indicate if we should defer to an existing session if found</summary>
        </member>
        <member name="P:ClientAPI.CUserInfo.BrandIdentifier">
            <summary>The brand identifier</summary>
        </member>
        <member name="P:ClientAPI.CUserInfo.ClientType">
            <summary>The type of client (for example EAT) used for display and reporting purposes only</summary>
        </member>
        <member name="P:ClientAPI.CUserInfo.Location">
            <summary>The location URL of the logon server for authentication</summary>
        </member>
        <member name="P:ClientAPI.CUserInfo.SecurePassword">
            <summary>For clients that support System.SecureString, this will be read in preference to the plain text <seealso cref="P:ClientAPI.CUserInfo.Password" />.</summary>
        </member>
        <member name="P:ClientAPI.CUserInfo.Password">
            <summary>Password can be changed externally many times, to allow for relogon attempts</summary>
        </member>
        <member name="M:ClientAPI.CUserInfo.set_Username(System.String)">
Throws System.FieldAccessException when attempting to set Username after it has been committed
</member>
        <member name="P:ClientAPI.CUserInfo.Username">
            <summary>The EasyRouter username. This property is mutable until the first logon attempt is made at which point it
is Committed and can no longer be changed.  Attempting to change the Username at this point will
raise a <seealso cref="T:System.FieldAccessException" />.</summary>
        </member>
        <member name="T:ClientAPI.CUserInfo.VersionResponse">
            <summary>Version response events are called in response to the VersionRequest method</summary>
            <remarks>Currently only returns text Not Implemented</remarks>
        </member>
        <member name="T:ClientAPI.CUserInfo.ProfileResponse">
            <summary>Profile response events called in response to the call to the ProfileRequest method</summary>
            <remarks>Deprecated and will be removed soon</remarks>
        </member>
        <member name="M:ClientAPI.IPersistence.DeleteMessages(System.String,System.Collections.Generic.List`1{System.String})">
            <summary>
Invokes a service method asynchronously that deletes a persisted piece of data from the server permanently.
<para>The result of the request is returned to the client asynchronously via the <see cref="E:ClientAPI.IPersistence.OnPersistenceDelete" /> event.</para></summary>
            <param name="categoryName">The categoryname (<see cref="P:EasyScreen.SOA2.GenericPersistence.PersistedMessageDataContract.CategoryName" />) that the message belongs to.</param>
            <param name="messageIDs">The id (<see cref="P:EasyScreen.SOA2.GenericPersistence.PersistedMessageDataContract.ClientGeneratedRecordID" />) that identifies the message within the <paramref name="categoryName" />.</param>
        </member>
        <member name="M:ClientAPI.IPersistence.GetMessageList(System.String)">
            <summary>
Invokes a service method asynchronously that returns a set of persisted data messages identical to the result from
<see cref="M:ClientAPI.IPersistence.GetMessages(System.String)" />.
<para>Returns a list of persisted data definitions (<see cref="T:EasyScreen.SOA2.GenericPersistence.PersistedMessageDataContract" />) that DO NOT
CONTAIN THE MESSAGE BODY (<see cref="P:EasyScreen.SOA2.GenericPersistence.PersistedMessageDataContract.Message" />. In other words we return a list
of headlines about messages that we can then request message details for via a request for specific messages through the
<see cref="M:ClientAPI.IPersistence.GetMessages(System.String,System.Collections.Generic.List`1{System.String})" /> method.</para><para>This method will return whilst an asynchronous request is made and the response will be returned through
<see cref="E:ClientAPI.IPersistence.OnMessageListReturn" /></para></summary>
            <param name="categoryName">The name of the category to get message headlines for.</param>
            <remarks>Calls the GetMessagesList method of the Persistence service.
<para>NOTE: THIS METHOD HAS NOT YET BEEN IMPLEMENTED IN THE SERVICE LAYER BUT WILL BE NEEDED.</para></remarks>
        </member>
        <member name="M:ClientAPI.IPersistence.GetMessages(System.String,System.Collections.Generic.List`1{System.String})">
            <summary>
Invokes a service method asynchronously that returns a list of all persisted data messages associated with the calling user and the 
<paramref name="categoryName" /> that is passed in restricted to messages identified by the message keys (
<see cref="P:EasyScreen.SOA2.GenericPersistence.PersistedMessageDataContract.ClientGeneratedRecordID" />) 
that are specified in <paramref name="messageIDs" />.
<para>This method will return whilst an asynchronous request is made and the response will be returned through
<see cref="E:ClientAPI.IPersistence.OnPersistedDataReturn" /></para><para>The result of this call is returned to the client via the <see cref="E:ClientAPI.IPersistence.OnPersistedDataReturn" /> event.</para></summary>
            <param name="categoryName">The name of the category that all persisted messages are to be returned for.</param>
            <param name="messageIDs">List of the <see cref="P:EasyScreen.SOA2.GenericPersistence.PersistedMessageDataContract.ClientGeneratedRecordID" />s that
identify the message set that is to be returned.</param>
            <remarks>Calls the GetMessages(String^, List&lt;String^&gt;^) method of the Persistence service.
<para>NOTE: THIS METHOD HAS NOT YET BEEN IMPLEMENTED IN THE SERVICE LAYER BUT WILL BE NEEDED.</para></remarks>
        </member>
        <member name="M:ClientAPI.IPersistence.GetMessages(System.String)">
            <summary>
Invokes a service method asynchronously that returns a list of all persisted data messages associated with the calling user and the 
<paramref name="categoryName" /> that is passed in.
<para>This method will return whilst an asynchronous request is made and the response will be returned through
<see cref="E:ClientAPI.IPersistence.OnPersistedDataReturn" /></para><para>The result of this call is returned to the client via the <see cref="E:ClientAPI.IPersistence.OnPersistedDataReturn" /> event.</para></summary>
            <param name="categoryName">The name of the category that all persisted messages are to be returned for.</param>
            <remarks>Calls the GetMessages(String^) method of the Persistence service.</remarks>
        </member>
        <member name="M:ClientAPI.IPersistence.PersistMessage(EasyScreen.SOA2.GenericPersistence.PersistedMessageDataContract,System.ValueType!System.Guid!System.Runtime.CompilerServices.IsBoxed)">
            <summary>
Called to persist a piece of information to EasyRouter through the generic data Persistence service.
<para>This method will return whilst an asynchronous request is made and the response will be returned through
<see cref="E:ClientAPI.IPersistence.OnPersistedMessage" /></para></summary>
            <param name="message">The message that is to be persisted.</param>
            <param name="requestId">An id that is provided by the client application that follows the message throughout the service processing. This is to
be used to allow users to tie asyncrhonous responses through <see cref="E:ClientAPI.IPersistence.OnPersistedMessage" />.
<para>Within the ClientAPI this should be used to populate the appropriate field within the SOAP header and read back from this field when a response
is received from the service architecture.
</para></param>
            <remarks>Calls the CreateMessage method of the Persistence service.</remarks>
        </member>
        <member name="M:ClientAPI.IPersistence.RefreshCategories">
            <summary>
Causes ClientAPI to attempt to refresh its its of categories as exposed through <see cref="P:ClientAPI.IPersistence.Categories" />. 
<para>This method will return whilst an asynchronous request is made and the response will be returned through
<see cref="E:ClientAPI.IPersistence.OnCategoriesAvailable" /></para></summary>
            <remarks>Calls the GetCategories method of the Persistence service.</remarks>
        </member>
        <member name="P:ClientAPI.IPersistence.Categories">
            <summary>
This returns a list of the categories that are available for the client to store persisted information in. The object returned will be either 
of type <see cref="T:EasyScreen.SOA2.ExceptionHandling.ESFault" /> if we are unavailable to retrieve the list, or a 
List&lt;<see cref="T:EasyScreen.SOA2.GenericPersistence.CategoryDataContract" />^&gt;
</summary>
            <remarks>Returns the categories returned from a call to the <see cref="M:ClientAPI.IPersistence.RefreshCategories" />
method of the Persistence service.</remarks>
        </member>
        <member name="E:ClientAPI.IPersistence.OnPersistenceDelete">
            <summary>
Raised when a response to a request to the Persistence service to delete a message has been received.
</summary>
            <remarks>Raised in response to a return from the <see cref="M:ClientAPI.IPersistence.DeleteMessages(System.String,System.Collections.Generic.List`1{System.String})" />
methods of the Persistence service.</remarks>
        </member>
        <member name="E:ClientAPI.IPersistence.OnMessageListReturn">
            <summary>
Raised when a response to a request for a list of messages within a specific category is returned from the service.
</summary>
            <remarks>Raised in response to a return from the <see cref="M:ClientAPI.IPersistence.GetMessageList(System.String)" />
methods of the Persistence service.</remarks>
        </member>
        <member name="E:ClientAPI.IPersistence.OnPersistedDataReturn">
            <summary>
Raised when response to a request to retrieve one or more persisted messages from the service is received.
</summary>
            <remarks>Raised in response to a return from the <see cref="M:ClientAPI.IPersistence.GetMessages(System.String)" />
methods of the Persistence service.</remarks>
        </member>
        <member name="E:ClientAPI.IPersistence.OnPersistedMessage">
            <summary>
Raised when a response to a request to persist a piece of data has been received.
</summary>
            <remarks>Raised in response to a return from the <see cref="M:ClientAPI.IPersistence.PersistMessage(EasyScreen.SOA2.GenericPersistence.PersistedMessageDataContract,System.ValueType!System.Guid!System.Runtime.CompilerServices.IsBoxed)" />
methods of the Persistence service.</remarks>
        </member>
        <member name="E:ClientAPI.IPersistence.OnCategoriesAvailable">
            <summary>
Raised when the ClientAPI has received a response to its request for a category listing.
</summary>
            <remarks>Raised in response to a return from the <see cref="M:ClientAPI.IPersistence.RefreshCategories" />
methods of the Persistence service.</remarks>
        </member>
        <member name="P:ClientAPI.CEventWrapperForServiceReturnWithResult`1.Categories">
            <summary>
Returns the results of the request made by the client application.
</summary>
        </member>
        <member name="T:ClientAPI.CEventWrapperForServiceReturnWithResult`1">
            <summary>
Encapsulates the results from a service that does return an output as opposed to the base class <see cref="T:ClientAPI.CEventWrapperForServiceReturn" />
(in other words the DataOperation returns something other than void).
</summary>
            <typeparam name="t" />
        </member>
        <member name="P:ClientAPI.CEventWrapperForServiceReturn.RequestId">
            <summary>
This is the id for the message that is set by the client in the orriginal request and that is passed through the service operations in 
the SOAP Header.
</summary>
        </member>
        <member name="P:ClientAPI.CEventWrapperForServiceReturn.Fault">
            <summary>
The <see cref="T:EasyScreen.SOA2.ExceptionHandling.ESFault" /> that describes the error that occured whilst performing the service action.
</summary>
        </member>
        <member name="P:ClientAPI.CEventWrapperForServiceReturn.Success">
            <summary>
Returns True if the activity was successful. If False is returned, an error occured and for details the client should examine
<see cref="P:ClientAPI.CEventWrapperForServiceReturn.Fault" />.
</summary>
        </member>
        <member name="T:ClientAPI.CEventWrapperForServiceReturn">
            <summary>
Encapsulates basic results from a service that does not ordinarily return an output (in other words the DataOperation returns void).
</summary>
        </member>
        <member name="M:ClientAPI.CManagement.ResetUserState(ClientAPI.CUserInfo)">
            <summary> This function can be used to reset the users logon request state to allow a retry if the user status
has managed to get into a bad state that will prevent another logon attempt </summary>
        </member>
        <member name="P:ClientAPI.CStructureItem.WaitEvent">
            <summary>Gets the wait handle that will be set when the instrument details arrive</summary>
        </member>
        <member name="P:ClientAPI.CStructureItem.PriceTypesSupported">
            <summary> Contains the types supported for this instrument </summary>
        </member>
        <member name="P:ClientAPI.CStructureItemLeg.PromptDesc">
            <summary> Contains the ratio value for this particular strategy leg </summary>
        </member>
        <member name="P:ClientAPI.CStructureItemLeg.PromptType">
            <summary> Contains the prompt type value for prompt style instruments (such as LME 3M) </summary>
        </member>
        <member name="P:ClientAPI.CStructureItemLeg.Ratio">
            <summary> Contains the ratio value for this particular strategy leg </summary>
        </member>
        <member name="P:ClientAPI.CStructureItemLeg.IsBuy">
            <summary> Contains the Buy/Sell side indicator for this particular strategy leg </summary>
        </member>
        <member name="P:ClientAPI.CStructureItemLeg.OptAttribute">
            <summary> Contains the option version for this particular leg, if leg is a Eurex option </summary>
        </member>
        <member name="P:ClientAPI.CStructureItemLeg.StrikePrice">
            <summary> Contains the strike price for this particular leg, if the leg is an option </summary>
        </member>
        <member name="P:ClientAPI.CStructureItemLeg.UnitTickValue">
            <summary> Contains the unit tick value for this particular leg </summary>
        </member>
        <member name="P:ClientAPI.CStructureItemLeg.CFICode">
            <summary> Contains the CFICode value for this particular leg </summary>
        </member>
        <member name="P:ClientAPI.CStructureItemLeg.ExpiryMonth">
            <summary> Contains the expiry year month (YYYYMM) value for this particular leg </summary>
        </member>
        <member name="P:ClientAPI.CStructureItemLeg.MaturityYearMonth">
            <summary> Contains the maturity year month (YYYYMM) value for this particular leg </summary>
        </member>
        <member name="P:ClientAPI.CStructureItemLeg.MaturityDay">
            <summary> Contains the maturity day (DD) value for this particular leg </summary>
        </member>
        <member name="P:ClientAPI.CStructureItemLeg.CurrencyCode">
            <summary> Contains the currency code for this particular leg </summary>
        </member>
        <member name="P:ClientAPI.CStructureItemLeg.Symbol">
            <summary> Contains the commodity code for this particular leg </summary>
        </member>
        <member name="P:ClientAPI.CStructureItemLeg.Mnemonic">
            <summary> Contains the EasyScreen mnemonic for this particular leg </summary>
        </member>
        <member name="T:ClientAPI.CStructureItemLeg">
            <summary> 
Every structure item will have at least one leg, to avoid complications the structure details
should be extracted via the leg information rather than the top level
</summary>
        </member>
        <member name="M:ClientAPI.CStructureDataStore.FireInstrumentLookupResponseEvent(System.Object,System.String)">
            <remarks> PAW 22 Jun 2010 - Return an object here. We can't overload the event declaration and its fairly standard within WPF GUIs to
evaluate the success of responses based on the type of the object that is passed, so we will either return a DataRequestResponse
for a success of an ESFault for a failure here. We also need to return the messsageId which is the Id used within the SOAP header
of the request and response message to identify the message and its response.</remarks>
        </member>
        <member name="P:ClientAPI.CEventWrapperInstrumentLookupResponse.MessageId">
            <summary>The ID of the request response combination as contained in the SOAP Header
MessageID and RelatesTo pair.</summary>
        </member>
        <member name="M:ClientAPI.CEventWrapperInstrumentLookupResponse.#ctor(System.Object,System.String)">
            <param name="strMessageId">The ID of the request response combination as contained in the SOAP Header
MessageID and RelatesTo pair.</param>
        </member>
        <member name="M:CRoutingThread.RunThread">
            <summary>Runs the main thread</summary>
        </member>
        <member name="P:ClientAPI.CEventWrapperMarketDataItem.LastTradeHistory">
            <summary>An ordered list of Last Trade events which have been received since the last synchronous event
invocation.  The earliest trade is first in the list, the latest trade is last.  If the only item of interest
is the Last Trade then use of the GetMarketDataEntry on the MarketDataItem is probably simpler.  Elements
in the list are created for the event, and will not be changed after creation, so can be safetly used
asynchronously if the client knows all the places they are planning no accessing the elements.</summary>
        </member>
        <member name="M:ClientAPI.CMarketDataItem.GetMarketDataDepth(System.UInt32,System.Boolean)">
            <summary>
Access to a bid or offer data set, based on a changed array set.  Note that the returned
array contains <b>copies</b> of the PVD items, not references to the internally stored entries.
</summary>
        </member>
        <member name="P:ClientAPI.CMarketDataItem.DepthState">
            <summary> Status of the depth data, set complete on depth image received </summary>
        </member>
        <member name="P:ClientAPI.CMarketDataItem.BestState">
            <summary> Status of the best data, set complete on best image received </summary>
        </member>
        <member name="P:ClientAPI.CMarketDataItem.State">
            <summary> Overall status of the item, set complete on first image received </summary>
        </member>
        <member name="M:ClientAPI.CMarketDataPVD.Clone">
            <summary> Returns a clone of this object </summary>
        </member>
        <member name="M:ClientAPI.CMarketDataStore.FindOrCreateItem(System.String)">
            <summary> Get an item from the cache, and create it if it does not exist </summary>
        </member>
        <member name="M:ClientAPI.CMarketDataStore.FindOrCreateItem(System.String,System.String)">
            <summary> Get an item from the cache, and create it if it does not exist </summary>
            <remarks> Depricated </remarks>
        </member>
        <member name="M:ClientAPI.CMarketDataStore.FindItem(System.String)">
            <summary> Get an item from the cache only if it exists </summary>
        </member>
        <member name="M:ClientAPI.CBusinessObjectBase.UnregisterChannelInterest(ClientAPI.EDataType,ClientAPI.EComponentType,System.String,System.String)">
            <summary>This function removes the business objects interest in a specific channel name as supplied by its constituent parts</summary>
            <param name="eChannelDataType">The channel <seealso cref="T:ClientAPI.EDataType" /> type that be used to trigger events on for the received data</param>
            <param name="eCompType">The <seealso cref="T:ClientAPI.EComponentType" /> for this channel type</param>
            <param name="strUnique">The <seealso cref="T:System.String" /> that describes the unqiue part of the channel interest</param>
            <param name="strGroup">The <seealso cref="T:System.String" /> that describes the group part of the channel interest, usually denotes the security exchange</param>
        </member>
        <member name="M:ClientAPI.CBusinessObjectBase.RegisterChannelInterest(ClientAPI.EDataType,ClientAPI.EComponentType,System.String,System.String,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>This function registers a business object in a specific channel name, with the channel properties and the sets 
the response data type for events on this channel.</summary>
            <param name="eChannelDataType">The channel <seealso cref="T:ClientAPI.EDataType" /> type that be used to trigger events on for the received data</param>
            <param name="eCompType">The <seealso cref="T:ClientAPI.EComponentType" /> for this channel type</param>
            <param name="strUnique">The <seealso cref="T:System.String" /> that describes the unqiue part of the channel interest</param>
            <param name="strGroup">The <seealso cref="T:System.String" /> that describes the group part of the channel interest, usually denotes the security exchange</param>
            <param name="dwChannelProperties">The properties of the new channel interest, use 1 for image or 0 for updates only</param>
            <example>To open an interest for orders for a specific account id of 23 from LIFFE and receive an image supply the following arguments: 
eChannelDataType=EDataType::eDataTypeOrder, eCompType=EComponentType::eComponentTypeOrders, strUnique="23", strGroup="L", dwChannelProperties=1
</example>
            <remarks>See the ClientAPI documentation for more details on channel name building</remarks>
        </member>
        <member name="M:ClientAPI.CBusinessObjectBase.UnregisterDataInterest(ClientAPI.EDataType)">
            <summary>This function takes a <seealso cref="T:ClientAPI.EDataType" /> type parameter and unregisters the business object 
from receiving events of that data type.</summary>
        </member>
        <member name="M:ClientAPI.CBusinessObjectBase.RegisterDataInterest(ClientAPI.EDataType)">
            <summary>This function takes a data type parameter and registers the business object in receiving events 
for that data type.</summary>
            <param name="eDataType">The data type that the business object is interested in, can be any of <seealso cref="T:ClientAPI.EDataType" />
enumerated values</param>
        </member>
        <member name="M:ClientAPI.CBusinessObjectBase.RouteMessageDirect(CMessageObject*)">
            <summary>This method will be used by to send a <seealso cref="T:CMessageObject" /> into the routing layer for distribution.
This method would be used over the other RouteMessage function when requiring to send the message
without queuing the request for processing, it will be processed directly instead</summary>
            <param name="pMessage">The <seealso cref="T:CMessageObject" /> to be sent to the communications layer</param>
            <returns>The function returns True if the message was successfully sent via the routing layer</returns>
        </member>
        <member name="M:ClientAPI.CBusinessObjectBase.RouteMessage(CMessageObject*)">
            <summary>This method will be used by all business objects to send a <seealso cref="T:CMessageObject" /> into the 
routing layer for distribution. The message is queued for processing and the method returns immediately</summary>
            <param name="pMessage">The <seealso cref="T:CMessageObject" /> to be sent to the communications layer</param>
            <returns>The function returns True if the message was successfully sent via the routing layer</returns>
        </member>
        <member name="M:ClientAPI.CBusinessObjectBase.Uninitialise">
            <summary>All business objects will need to override this method to do their own clean up, 
and then call the base version to allow it to clean up the base template objects.</summary>
        </member>
        <member name="M:ClientAPI.CBusinessObjectBase.Initialise(ClientAPI.CManagement)">
            <summary>All business objects will need to override this method to do their own forms of
initialisation and then call the base version to allow it to set up the base template objects.
It will take a reference to a management business object that will be cached internally for use 
to access data store objects. The management object will take a null pointer here to avoid cyclic 
references.</summary>
            <param name="ManagementObject">The <seealso cref="T:ClientAPI.CManagement">management</seealso> singleton object</param>
        </member>
        <member name="T:ClientAPI.CBusinessObjectBase.ProgressUpdate">
            <summary>Delegate declaration for process updates events during asyncronous calls</summary>
            <remarks>Progress updates are only supported by Logon and logoof calls made via the CManagement interface currently
but should be extended to other calls as time allows</remarks>
        </member>
        <member name="T:ClientAPI.CBusinessObjectBase.InputStyleData">
            <summary>Delegate declaration for events that will triggered by the <seealso cref="T:ClientAPI.EDataType" /> value eDataTypeInputStyle</summary>
        </member>
        <member name="T:ClientAPI.CBusinessObjectBase.RiskData">
            <summary>Delegate declaration for events that will triggered by the <seealso cref="T:ClientAPI.EDataType" /> value eDataTypeRisk</summary>
        </member>
        <member name="T:ClientAPI.CBusinessObjectBase.AccountData">
            <summary>Delegate declaration for events that will triggered by the <seealso cref="T:ClientAPI.EDataType" /> value eDataTypeAccount</summary>
        </member>
        <member name="T:ClientAPI.CBusinessObjectBase.StatusData">
            <summary>Delegate declaration for events that will triggered by the <seealso cref="T:ClientAPI.EDataType" /> value eDataTypeStatus</summary>
        </member>
        <member name="T:ClientAPI.CBusinessObjectBase.OrderData">
            <summary>Delegate declaration for events that will triggered by the <seealso cref="T:ClientAPI.EDataType" /> value eDataTypeOrder</summary>
        </member>
        <member name="T:ClientAPI.CBusinessObjectBase.StructureData">
            <summary>Delegate declaration for events that will triggered by the <seealso cref="T:ClientAPI.EDataType" /> value eDataTypeStructure</summary>
        </member>
        <member name="T:ClientAPI.CBusinessObjectBase.PriceDepthData">
            <summary>Delegate declaration for events that will triggered by the <seealso cref="T:ClientAPI.EDataType" /> value eDataTypePriceDepth</summary>
        </member>
        <member name="T:ClientAPI.CBusinessObjectBase.PriceBestData">
            <summary>Delegate declaration for events that will triggered by the <seealso cref="T:ClientAPI.EDataType" /> value eDataTypePriceBest</summary>
        </member>
        <member name="T:ClientAPI.CBusinessObjectBase.GeneralData">
            <summary>Delegate declaration for events that will triggered by the <seealso cref="T:ClientAPI.EDataType" /> value eDataTypeGeneral</summary>
        </member>
        <member name="T:ClientAPI.CBusinessObjectBase">
            <summary>This template will be used as a start point for all business objects in the Business Layer. 
This template will not be creatable directly and should only be used to provide the base set of 
functionality in each business object specialisation</summary>
        </member>
        <member name="M:CMessageObjectDeleteStoredMessageResponse.#ctor(CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <param name="strRequestId">An identifier that will be reflected back on the response to enable the two to be linked</param>
        </member>
        <member name="T:CMessageObjectDeleteStoredMessageResponse">
            <summary>This object to used to update the user from the deletion request</summary>
        </member>
        <member name="M:CMessageObjectDeleteStoredMessageRequest.#ctor(CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.list&lt;CEasyString&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <param name="strUsername">The username for the user that is making the list request</param>
            <param name="strPassword">The password for the requesting user</param>
            <param name="strCategory">The category this message belongs to (from the list of existing categories allow for this user)</param>
            <param name="strRequestId">Optional. An identifier that will be reflected back on the response to enable the two to be linked</param>
        </member>
        <member name="T:CMessageObjectDeleteStoredMessageRequest">
            <summary>This object is used to request a set of messages be deleted for a supplied set of keys with 
a single supplied category</summary>
        </member>
        <member name="M:CMessageObjectStoredMessageSummaryResponse.GetMessageSummaries">
            <summary>Retrieves the list of cached messages</summary>
        </member>
        <member name="M:CMessageObjectStoredMessageSummaryResponse.AddMessageSummary(CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>This function adds all the retrieved message summary fields to the collection held in this object</summary>
            <param name="strCategory">The category this message belongs to</param>
            <param name="strKey">The client supplied unique key for this message within the category</param>
            <param name="strDescription">A client supplied short description for the message</param>
            <param name="strFreeText">A free text field the client can use to add further text to the stored message</param>
        </member>
        <member name="M:CMessageObjectStoredMessageSummaryResponse.#ctor(CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Constructor for the CMessageObjectStoredMessageSummaryResponse message object which returns one or more message
summaries retrieved from the persistence store. The summary should contain all the fields except the message itself</summary>
            <param name="strUsername">The username for the user that made the request</param>
            <param name="strRequestId">An identifier that will be reflected back on the response to enable the two to be linked</param>
            <param name="bSuccess">Status value for the request</param>
        </member>
        <member name="T:CMessageObjectStoredMessageSummaryResponse">
            <summary>This object is used to return a collection of stored message summaries to the requesting
user</summary>
        </member>
        <member name="M:CMessageObjectStoredMessageSummaryRequest.#ctor(CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> This object is sent to request the summary information for the avialable stored messages, excluding the message itself</summary>
            <param name="strUsername">The username for the user that is making the list request</param>
            <param name="strPassword">The password for the requesting user</param>
            <param name="strCategory">The category this message belongs to (from the list of existing categories allow for this user)</param>
            <param name="strRequestId">Optional. An identifier that will be reflected back on the response to enable the two to be linked</param>
        </member>
        <member name="T:CMessageObjectStoredMessageSummaryRequest">
            <summary>This object is used to request a summary of stored messages from the persisted store</summary>
        </member>
        <member name="M:CMessageObjectFilteredStoredMessageListRequest.#ctor(CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.list&lt;CEasyString&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Constructor for request for filtered set of storage details, filtered by category and supplied list of message keys</summary>
            <param name="strUsername">The username for the user that is making the list request</param>
            <param name="strPassword">The password for the requesting user</param>
            <param name="strCategory">The category this message belongs to (from the list of existing categories allow for this user)</param>
            <param name="lstMessageKeys" />
            <param name="strRequestId">Optional. An identifier that will be reflected back on the response to enable the two to be linked</param>
        </member>
        <member name="T:CMessageObjectFilteredStoredMessageListRequest">
            <summary>This object is used to request a set of stored messages, filtered by the collection 
of supplied client keys. The response to this object will be a CMessageObjectStoredMessageListResponse
message object</summary>
        </member>
        <member name="M:CMessageObjectStoredMessageListResponse.GetMessageDetails">
            <summary>Retrieves the list of cached messages</summary>
        </member>
        <member name="M:CMessageObjectStoredMessageListResponse.AddMessageDetails(CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>This function adds all the retrieved message fields and the message itself to the collection held in this object</summary>
            <param name="strCategory">The category this message belongs to</param>
            <param name="strKey">The client supplied unique key for this message within the category</param>
            <param name="strDescription">A client supplied short description for the message</param>
            <param name="strFreeText">A free text field the client can use to add further text to the stored message</param>
            <param name="strMessage">The stored message itself</param>
        </member>
        <member name="M:CMessageObjectStoredMessageListResponse.#ctor(CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Constructor for the CMessageObjectStoredMessageListResponse message object which returns one or more messages
retrieved from the persistence store</summary>
            <param name="strUsername">The username for the user that made the request</param>
            <param name="strRequestId">An identifier that will be reflected back on the response to enable the two to be linked</param>
            <param name="bSuccess">Status value for the request</param>
        </member>
        <member name="T:CMessageObjectStoredMessageListResponse">
            <summary> This object will be sent to return the list of stored messages for the given user and category </summary>
        </member>
        <member name="D:CMessageDetailsList">
            <summary> A typedef for a collection of mesage details </summary>
        </member>
        <member name="T:CMessageDetails">
            <summary> Structure used to hold the set of message fields, this should match the members of the PersistedMessageDataContract
in the interface (but that is managed so not usable here) </summary>
        </member>
        <member name="D:CMessageSummaryList">
            <summary>A collection of messages summary information </summary>
        </member>
        <member name="T:CMessageSummary">
            <summary> Structure used to hold the set of message fields, exckuding the message itself</summary>
        </member>
        <member name="M:CMessageObjectStoredMessageListRequest.GetCategory">
            <summary> Category this stored message belongs to, must be one from list of valid categories returns for this user </summary>
        </member>
        <member name="M:CMessageObjectStoredMessageListRequest.#ctor(CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Constructor for the message list request</summary>
            <param name="strUsername">The username for the user that is making the list request</param>
            <param name="strPassword">The password for the requesting user</param>
            <param name="strCategory">The category this message belongs to (from the list of existing categories allow for this user)</param>
            <param name="strRequestId">Optional. An identifier that will be reflected back on the response to enable the two to be linked</param>
        </member>
        <member name="T:CMessageObjectStoredMessageListRequest">
            <summary> This object should be sent to request the current list of stored messages for a given category for this user </summary>
        </member>
        <member name="M:CMessageObjectStoreMessageResponse.#ctor(CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Constructor for returning the result of a storage request</summary>
            <param name="strUsername">The username for the user that made the request</param>
            <param name="strRequestId">An identifier that will be reflected back on the response to enable the two to be linked</param>
            <param name="bSuccess">Status value for the request</param>
        </member>
        <member name="T:CMessageObjectStoreMessageResponse">
            <summary> This object will be sent to the requesting user of the store message request </summary>
        </member>
        <member name="M:CMessageObjectStoreMessageRequest.GetFreeText">
            <summary> Optional free text field </summary>
        </member>
        <member name="M:CMessageObjectStoreMessageRequest.GetDescription">
            <summary> Optional description field </summary>
        </member>
        <member name="M:CMessageObjectStoreMessageRequest.GetKey">
            <summary> Client supplied unique identifier for this storage message within this category for this user </summary>
        </member>
        <member name="M:CMessageObjectStoreMessageRequest.GetCategory">
            <summary> Category this stored message belongs to, must be one from list of valid categories returns for this user </summary>
        </member>
        <member name="M:CMessageObjectStoreMessageRequest.#ctor(CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.Compile">
            <summary>Constructor for the message store request</summary>
            <param name="strUsername">The username for the user that is making the storage request</param>
            <param name="strPassword">The password for the requesting user</param>
            <param name="strMessage">The message that is to be stored (ASCII data only)</param>
            <param name="strCategory">The category this message belongs to (from the list of existing categories allow for this user)</param>
            <param name="strKey">The users own identifier for this message, must be unique for given user and category or will overwrite previous entry</param>
            <param name="strDesc">Optional. Description field to be stored with the message</param>
            <param name="strText">Optional. Free text field to be stored with the message</param>
            <param name="strRequestId">Optional. An identifier that will be reflected back on the response to enable the two to be linked</param>
        </member>
        <member name="T:CMessageObjectStoreMessageRequest">
            <summary> This object should be sent to store a particular message via the web service for the given category
using the unique client reference for this user</summary>
        </member>
        <member name="M:CMessageObjectStorageCategoriesResponse.GetCategories">
            <summary>Extraction method for retrieving the returned list of categories</summary>
        </member>
        <member name="M:CMessageObjectStorageCategoriesResponse.#ctor(CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.map&lt;CEasyString,CEasyString&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Constructor for returning the available list of categories for the requesting user</summary>
            <param name="strUsername">The username for the user that made the request</param>
            <param name="lsCategories">A dictionary of available categories and a short description for each</param>
            <param name="strRequestId">An identifier that will be reflected back on the response to enable the two to be linked</param>
        </member>
        <member name="T:CMessageObjectStorageCategoriesResponse">
            <summary> This object should be sent to return the list of storage categories available for 
the given user back to the requestor</summary>
        </member>
        <member name="M:CMessageObjectStorageCategoriesRequest.#ctor(CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Constructor for making a storage categories request to the web services</summary>
            <param name="strUsername">The username for the user that is making the storage request</param>
            <param name="strPassword">The password for the requesting user</param>
            <param name="strRequestId">Optional. An identifier that will be reflected back on the response to enable the two to be linked</param>
        </member>
        <member name="T:CMessageObjectStorageCategoriesRequest">
            <summary> This object should be sent to request the list of storage categories available for 
the given user </summary>
        </member>
        <member name="T:CMessageObjectVersionResponse">
            <summary>This response indicates if any upgrades are available to the client</summary>
        </member>
        <member name="T:CMessageObjectVersionRequest">
            <summary>This object should be sent to inform the server of binary versions, and the response indicates
if any upgrades are available.</summary>
        </member>
        <member name="T:CMessageObjectProfileResponse">
            <summary>This object should be return profile entries as a resultset of the CMessageObjectProfileRequest</summary>
        </member>
        <member name="T:CMessageObjectProfileRequest">
            <summary>This object should be sent to get/set/remove profiles or profile entries, and also to query the
list of profile names - all this is encoded in the XML document, which is interpreted by the
recipient system (ie, web service)</summary>
        </member>
        <member name="T:CMessageObjectInstrumentLookupResponse">
            <summary>This object should be sent to respond to the user from the the instrument lookup request</summary>
        </member>
        <member name="T:CMessageObjectInstrumentLookup">
            <summary>This object should be sent to attempt to lookup an instrument within EasyRouter</summary>
        </member>
        <member name="M:CMessageObjectWebServiceResponse.GetSuccess">
            <summary>Retrieves the status value of the response, success or fail</summary>
        </member>
        <member name="M:CMessageObjectWebServiceResponse.GetPassword">
            <summary>Retrieves the user password used for web sevice call authentication</summary>
        </member>
        <member name="M:CMessageObjectWebServiceResponse.#ctor(ClientAPI.EMessageType,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Void*,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>Constructor for the object CMessageObjectWebServiceRequest, which is the base object for all web service requests</summary>
            <param name="eMessageType">The actual specific message type this object represents, allows casting back to specialised type from base type</param>
            <param name="strUsername">The user who is making the request</param>
            <param name="strRequestID">Optional parameter on a request that will be reflected back on the response</param>
            <param name="bSuccess">Status value for the response, success or fail</param>
            <param name="pData">The data that represents the request as a raw buffer</param>
            <param name="dwDataLength">The data length of the raw buffer that is holding the request</param>
        </member>
        <member name="M:CMessageObjectWebServiceResponse.#ctor(ClientAPI.EMessageType,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Xml.XmlDocument)">
            <summary>Constructor for the object CMessageObjectWebServiceRequest, which is the base object for all web service requests</summary>
            <param name="eMessageType">The actual specific message type this object represents, allows casting back to specialised type from base type</param>
            <param name="strUsername">The user who is making the request</param>
            <param name="strRequestID">Optional parameter on a request that will be reflected back on the response</param>
            <param name="bSuccess">Status value for the response, success or fail</param>
            <param name="xmlResponse">The data that represents the request in XML form</param>
        </member>
        <member name="M:CMessageObjectWebServiceResponse.#ctor(ClientAPI.EMessageType,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Constructor for the object CMessageObjectWebServiceResponse, which is the base object for all web service responses</summary>
            <param name="eMessageType">The actual specific message type this object represents, allows casting back to specialised type from base type</param>
            <param name="strUsername">The user who is making the request</param>
            <param name="strRequestID">Optional parameter on a request that will be reflected back on the response</param>
            <param name="bSuccess">Status value for the response, success or fail</param>
        </member>
        <member name="T:CMessageObjectWebServiceResponse">
            <summary> This object should be the base class of all web service responses to enable storage
and retrieval of failure details in a consistent way</summary>
        </member>
        <member name="M:CMessageObjectWebServiceRequest.GetPassword">
            <summary>Retrieves the user password used for web sevice call authentication</summary>
        </member>
        <member name="M:CMessageObjectWebServiceRequest.#ctor(ClientAPI.EMessageType,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Void*,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>Constructor for the object CMessageObjectWebServiceRequest, which is the base object for all web service requests</summary>
            <param name="eMessageType">The actual specific message type this object represents, allows casting back to specialised type from base type</param>
            <param name="strUsername">The user who is making the request</param>
            <param name="strPassword">The password for the user who is making the request</param>
            <param name="strRequestID">Optional parameter on a request that will be reflected back on the response</param>
            <param name="pData">The data that represents the request as a raw buffer</param>
            <param name="dwDataLength">The data length of the raw buffer that is holding the request</param>
        </member>
        <member name="M:CMessageObjectWebServiceRequest.#ctor(ClientAPI.EMessageType,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Xml.XmlDocument)">
            <summary>Constructor for the object CMessageObjectWebServiceRequest, which is the base object for all web service requests</summary>
            <param name="eMessageType">The actual specific message type this object represents, allows casting back to specialised type from base type</param>
            <param name="strUsername">The user who is making the request</param>
            <param name="strPassword">The password for the user who is making the request</param>
            <param name="strRequestID">Optional parameter on a request that will be reflected back on the response</param>
            <param name="xmlResponse">The data that represents the request in XML form</param>
        </member>
        <member name="M:CMessageObjectWebServiceRequest.#ctor(ClientAPI.EMessageType,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Constructor for the object CMessageObjectWebServiceRequest, which is the base object for all web service requests</summary>
            <param name="eMessageType">The actual specific message type this object represents, allows casting back to specialised type from base type</param>
            <param name="strUsername">The user who is making the request</param>
            <param name="strPassword">The password for the user who is making the request</param>
            <param name="strRequestID">Optional parameter on a request that will be reflected back on the response</param>
        </member>
        <member name="T:CMessageObjectWebServiceRequest">
            <summary> This object should be the base class of all web service requests to enable storage
and retrieval of usernames and passwords in a consistent way</summary>
        </member>
        <member name="M:CMessageObjectWebServiceData.GetRequestID">
            <summary>Retrieves the optional request id specified on requests and responses</summary>
        </member>
        <member name="M:CMessageObjectWebServiceData.GetUsername">
            <summary>Retrieves the web service user that will be used for request authentication and response reference</summary>
        </member>
        <member name="M:CMessageObjectWebServiceData.#ctor(ClientAPI.EMessageType,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Void*,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>Constructor for the object CMessageObjectWebServiceData, which is the base object for all web service requests and responses</summary>
            <param name="eMessageType">The actual specific message type this object represents, allows casting back to specialised type from base type</param>
            <param name="strUsername">The user who is making the request</param>
            <param name="strRequestID">Optional parameter on a request that will be reflected back on the response</param>
            <param name="pData">The data that represents the request or response as a raw buffer</param>
            <param name="dwDataLength">The data length of the raw buffer that is holding the request or the response</param>
        </member>
        <member name="M:CMessageObjectWebServiceData.#ctor(ClientAPI.EMessageType,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Xml.XmlDocument)">
            <summary>Constructor for the object CMessageObjectWebServiceData, which is the base object for all web service requests and responses</summary>
            <param name="eMessageType">The actual specific message type this object represents, allows casting back to specialised type from base type</param>
            <param name="strUsername">The user who is making the request</param>
            <param name="strRequestID">Optional parameter on a request that will be reflected back on the response</param>
            <param name="xmlData">The data that represents the request or response in XML form</param>
        </member>
        <member name="M:CMessageObjectWebServiceData.#ctor(ClientAPI.EMessageType,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEasyString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Constructor for the object CMessageObjectWebServiceData, which is the base object for all web service requests and responses</summary>
            <param name="eMessageType">The actual specific message type this object represents, allows casting back to specialised type from base type</param>
            <param name="strUsername">The user who is making the request</param>
            <param name="strRequestID">Optional parameter on a request that will be reflected back on the response</param>
        </member>
        <member name="T:CMessageObjectWebServiceData">
            <summary> This object should be the base class of all web service requests and responses to 
and retrieval of common fields in a consistent way. All web service requests require authentication
and all responses should be linked to the request</summary>
        </member>
    </members>
</doc>